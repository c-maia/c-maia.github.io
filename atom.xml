<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Blowing Brains]]></title>
  <link href="http://c-maia.github.io/atom.xml" rel="self"/>
  <link href="http://c-maia.github.io/"/>
  <updated>2020-12-28T19:36:07+00:00</updated>
  <id>http://c-maia.github.io/</id>
  <author>
    <name><![CDATA[ClÃ¡udio Maia]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Bitwising How Do Bitwise Operations Work]]></title>
    <link href="http://c-maia.github.io/blog/2020/12/23/bitwising-how-do-bitwise-operations-work/"/>
    <updated>2020-12-23T00:00:00+00:00</updated>
    <id>http://c-maia.github.io/blog/2020/12/23/bitwising-how-do-bitwise-operations-work</id>
    <content type="html"><![CDATA[<!-- wp:paragraph -->


<p>I have a bad memory concerning particular details of programming languages which I don't use very often, and bitwise operations are a good example of such details. Therefore, I decided to develop a Java program that serves the purpose of recapping the concepts that I've learned in school a few years ago.</p>


<!-- /wp:paragraph -->




<!-- wp:paragraph -->


<p>In the following table one may find a short overview of the operations that are covered in the simple program below.</p>


<!-- /wp:paragraph -->




<!-- wp:table -->


<figure class="wp-block-table"><table><tbody><tr><td>Operator</td><td>Name</td><td>Description</td><td>Examples</td></tr><tr><td>~</td><td>not</td><td>Unary operation that performs logical negation on each bit. After negation, bits that have the value 0 will have value 1 and the ones having value 1 will have value 0.</td><td>~4 = -5~&nbsp;00000100
<p>&nbsp;</p>
<p>=11111011</p>
</td></tr><tr><td>&amp;</td><td>and</td><td>Performs the logical AND operation on pairs of corresponding bits of the different numbers. The result is 1 if the pair of bits under comparison is 1, and 0 otherwise.</td><td>7&amp;1 = 100000111 &amp;
<p>&nbsp;</p>
<p>00000001 =</p>
<p>00000001</p>
</td></tr><tr><td>|</td><td>or</td><td>Performs the logical inclusive OR operation on pairs of corresponding bits of the different numbers. The result is 1 if <strong>at least</strong> one of the bits of the pair under comparison is 1, and 0 otherwise.</td><td>7 | 1 = 700000111 |
<p>&nbsp;</p>
<p>00000001 =</p>
<p>00000111</p>
</td></tr><tr><td>^</td><td>xor</td><td>Performs the exclusive OR operation on pairs of corresponding bits of the different numbers. The result is 1 if the pair of bits under comparison is different, and 0 otherwise.</td><td>7^1 = 600000111 ^
<p>&nbsp;</p>
<p>00000001 =</p>
<p>00000110</p>
</td></tr><tr><td>&lt;&lt;</td><td>signed left shift</td><td>Shifts the bit pattern on the left operand n positions to the left. Value n is specified by the right hand side operand. Bits with value of 0 are shifted into the low order positions. Equivalent to multiply by 2, the result of the operation <strong>value &lt;&lt; n</strong> is the same as calculating the expression<strong> value * (2^n)</strong>.</td><td>&nbsp;7 &lt;&lt; 2 =&nbsp;2800000111 &lt;&lt; 2
<p>&nbsp;</p>
<p>=00011100</p>
</td></tr><tr><td>&gt;&gt;</td><td>signed right shift</td><td>Shifts the bit pattern on the left operand n positions to the right. Value n is specified by the right hand side operand. Bits with value of 0 or 1 are shifted into the high order positions in order to preserve the sign. Equivalent to divide by 2. the result of the operation <strong>value &gt;&gt; n</strong> is the same as calculating the expression <strong>value / (2^n)</strong>.</td><td>7 &gt;&gt; 2 = 100000111 &gt;&gt; 2
<p>&nbsp;</p>
<p>=00000001</p>
</td></tr><tr><td>&gt;&gt;&gt;</td><td>unsigned right shift</td><td>This operation is identical to the signed right shift operation with the exception that it inserts 0 in the high order bits, therefore the sign value may change.If the left hand side operand is <strong>positive</strong>, the result will be the same as the signed right shift operation.
<p>&nbsp;</p>
<p>If the left hand side operand is <strong>negative</strong>, the result is equivalent to right shift n positions, specified by the value on the right hand side operand, of the bit pattern on the left-hand side operand. As the high order bits will be zero filled, the sign may change.</p>
</td><td>7 &gt;&gt;&gt; 2 = 100000111 &gt;&gt;&gt; 2
<p>&nbsp;</p>
<p>=00000001</p>
<p>Note: An example with negative numbers is provided in the source code.</p>
</td></tr></tbody></table></figure>


<!-- /wp:table -->




<!-- wp:paragraph -->


<p><strong>Bitwise Operators Demo</strong></p>


<!-- /wp:paragraph -->




<!-- wp:paragraph -->


<p>The program is rather simple. It generates two random numbers between 0 and 5000, and then applies the bitwise operations to the numbers generated.</p>


<!-- /wp:paragraph -->




<!-- wp:paragraph -->


<p>A special method for printing the binary representation of the number was used<br>because AFAIK the method "Integer.toBinaryString(...)" does not return the most<br>significant part of the binary numbers and for my purpose I wanted to have this<br>part represented in the output.</p>


<!-- /wp:paragraph -->




<!-- wp:paragraph -->


<p><strong>Output</strong></p>


<!-- /wp:paragraph -->




<!-- wp:paragraph -->


<p>The generated output is a set of messages containing the results of the performed<br>operations, and looks like this:</p>


<!-- /wp:paragraph -->




<!-- wp:preformatted -->


<pre class="wp-block-preformatted">* Operator: AND &amp;
 Binary representation: 00001000 10101101 - Decimal Representation: 2221
 Binary representation: 00000101 00001000 - Decimal Representation: 1288
 Binary representation: 00000000 00001000 - Decimal Representation: 8</pre>


<!-- /wp:preformatted -->




<!-- wp:paragraph -->


<p><strong><br>Source Code</strong></p>


<!-- /wp:paragraph -->




<!-- wp:preformatted -->


<pre class="wp-block-preformatted">package examples.operators.bitwise;

import java.util.Random;

public class BitwiseOperators
{
public static void main(String[] args)
{
System.out.println("*************************");
System.out.println("* Bitwise Operators Demo");
System.out.println("*************************");

// generate a random Integer between 0 and 5000
Random randomNumber = new Random();
int firstValueGenerated = randomNumber.nextInt(5000);
int secondValueGenerated = randomNumber.nextInt(5000);

System.out.println("First Generated Integer: " + firstValueGenerated);
System.out.println("Second Generated Integer: " + secondValueGenerated);

// print generated numbers in binary
IntToBinary(firstValueGenerated);
IntToBinary(secondValueGenerated);

System.out.println(" ");
System.out.println("*************************");
System.out.println("* Operations &amp; Results   ");
System.out.println("*************************");

System.out.println(" ");
System.out.println("* Operator: NOT (Complement) ~ ");
IntToBinary(firstValueGenerated);
IntToBinary(~firstValueGenerated);

System.out.println(" ");
System.out.println("* Operator: Negative -");
IntToBinary(firstValueGenerated);
IntToBinary(-firstValueGenerated);

System.out.println(" ");
System.out.println("* Operator: AND &amp;");

IntToBinary(firstValueGenerated);
IntToBinary(secondValueGenerated);
IntToBinary(firstValueGenerated &amp; secondValueGenerated);

System.out.println(" ");
System.out.println("* Operator: OR |");

IntToBinary(firstValueGenerated);
IntToBinary(secondValueGenerated);
IntToBinary(firstValueGenerated | secondValueGenerated);

System.out.println(" ");
System.out.println("* Operator: XOR ^");

// 1 if the two bits are different, and 0 if they are the same.
IntToBinary(firstValueGenerated);
IntToBinary(secondValueGenerated);
IntToBinary(firstValueGenerated ^ secondValueGenerated);

System.out.println(" ");
System.out.println("* Operator: Signed left shift &lt;&lt; (i.e. value &lt;&lt; 2)");

IntToBinary(firstValueGenerated);
IntToBinary(firstValueGenerated &lt;&lt; 2); System.out.println(" "); System.out.println("* Operator: Signed right shift >> (i.e. value >> 2)");

IntToBinary(firstValueGenerated);
IntToBinary(firstValueGenerated >> 2);

System.out.println(" ");
System.out.println("* Operator: Unsigned right shift >>> (i.e. value >>> 2)");

IntToBinary(firstValueGenerated);
IntToBinary(firstValueGenerated >>> 2);

System.out.println(" ");
System.out.println("* Operator: Unsigned right shift >> (Negative values: -16 >> 2)");
IntToBinary(-16);
IntToBinary(-16 >> 2);

System.out.println(" ");
System.out.println("* Operator: Unsigned right shift >>> (Negative values: -16 >>> 2)");
IntToBinary(-16);
IntToBinary(-16 >>> 2);

System.out.println(" ");
System.out.println("* Operator: Unsigned right shift >>> (Negative values: -1 >>> 24)");
IntToBinary(-1);
IntToBinary(-1 >>> 24);
}

private static void IntToBinary(int number)
{
String binaryNumber = new String();

// used for formatting the string
int counter = 0;

// check each bit of the number
for (int i = 31; i >= 0; i--)
{
/*
* Here we are interested in the result of the AND operation:
*
* If the AND operation returns a binary number different than 0
* that means that there was a match between the "mask" that we
* are applying and the number, therefore the string value will be 1
*
* If the AND operation returns 0 that means that the "mask" didn't
* match any bit of the number, therefore the number will be 0
*
*/

if( ((1 &lt;&lt;span                data-mce-type="bookmark"                id="mce_SELREST_start"              data-mce-style="overflow:hidden;line-height:0"              style="overflow:hidden;line-height:0"           >&lt;/span>&lt; i) &amp; number) != 0)
{
binaryNumber += "1";
}
else
{
binaryNumber += "0";
}

// separate each 8 bits with a space except the last octet
counter++;
if(counter % 8 == 0 &amp;&amp; i != 0)
{
binaryNumber += " ";
}
}

System.out.println("Binary representation: " + binaryNumber +
" - Decimal Representation: " + number);
}
}</pre>


<!-- /wp:preformatted -->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Undefined Reference to __udivdi3]]></title>
    <link href="http://c-maia.github.io/blog/2010/08/13/undefined-reference-udivdi3/"/>
    <updated>2010-08-13T23:03:56+00:00</updated>
    <id>http://c-maia.github.io/blog/2010/08/13/undefined-reference-udivdi3</id>
    <content type="html"><![CDATA[<p>During the last month I have been playing with real-time scheduling in the Linux kernel. Iâve downloaded the SCHED_DEADLINE implementation from their git repository and did some changes in some files in order to understand better how real-time task scheduling can be handled in Linux using this particular scheduling policy.</p>

<!-- more -->


<p>I used a 64-bit machine with Ubuntu and Eclipse CDT version to implement my modifications.</p>

<p><strong>You may wonder why do I use Eclipse?</strong><br/>
The answer to that is simple. Eclipse has great code indexing and cross-reference features, which are very helpful in understanding the kernel&rsquo;s inner details.</p>

<p>Moving back to the subject of this post, in my 64-bit machine Iâm able to compile a modified version of the kernel without any kind of problems but Iâm not able to run the compiled version. After some discussion with an expert in the subject, he told me that probably I wasnât compiling the correct modules that would allow me to run the OS without any problems. Thus, I decided to re-compile the same modified version in an old 32-bit machine which I wasnât using anymore, to see if I was able to, at least, run the modified version of the kernel.</p>

<p>The processors I&rsquo;m using are the following:</p>

<p>64-bit machine architecture: &ldquo;model name    : AMD Turion&trade; X2 Dual-Core Mobile RM-74&rdquo;
32-bit machine architecture: &ldquo;model name    : Intel&reg; M processor 1.60GHz&rdquo;</p>

<p>I confess that initially I thought that the compilation process would be smooth, but I got surprised when the code didnât compile and gcc threw an <strong>Undefined reference to __udivdi3</strong> error.</p>

<p>After some googling, I discovered that the error was thrown in a line where <strong>a division involving u64 data types was being done</strong>. Iâve found some good pointers to the problem, namely:</p>

<p><a href="http://kerneltrap.org/mailarchive/linux-kernel-newbies/2009/2/5/4902104">http://kerneltrap.org/mailarchive/linux-kernel-newbies/2009/2/5/4902104</a><br/>
<a href="https://bugs.launchpad.net/ubuntu/+source/linux-meta/+bug/237528">https://bugs.launchpad.net/ubuntu/+source/linux-meta/+bug/237528</a></p>

<p>So, according to the above posts, it looks like the problem is caused by a compatibility issue between the kernel sources and gcc v4.3. Well, that made sense to consider as I was using that version in the 32-bit machine. However, after an update of the gcc version to v4.4.3, I still got the same error in the 32-bit machine and, surprisingly, with the same version in my 64-bit machine, the kernel compiles smoothly. So, definitely, this was not a compiler&rsquo;s problem but, most probably, an error related to the machineâs architecture and how 64-bit division is performed.</p>

<p>After some googling (again), Iâve found this Stack Overflow thread that somehow fundaments my suspicions: <a href="https://stackoverflow.com/questions/1063585/udivdi3-undefined-how-to-find-the-code-that-uses-it">https://stackoverflow.com/questions/1063585/udivdi3-undefined-how-to-find-the-code-that-uses-it</a></p>

<p>Indeed, it is an architecture&rsquo;s related issue and how division is being handled. After modifying the kernel&rsquo;s code to perform a 64-bit division in a 32-bit architecture, using the <code>uint32_t do_div(uint64_t dividend, uint32_t divisor)</code> function, the code compiled like a charm.</p>

<p>And now letâs run the kernel!</p>
]]></content>
  </entry>
  
</feed>

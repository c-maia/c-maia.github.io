<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Blowing Brains]]></title>
  <link href="http://c-maia.github.io/atom.xml" rel="self"/>
  <link href="http://c-maia.github.io/"/>
  <updated>2020-12-28T19:36:07+00:00</updated>
  <id>http://c-maia.github.io/</id>
  <author>
    <name><![CDATA[Cláudio Maia]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Bitwising How Do Bitwise Operations Work]]></title>
    <link href="http://c-maia.github.io/blog/2020/12/23/bitwising-how-do-bitwise-operations-work/"/>
    <updated>2020-12-23T00:00:00+00:00</updated>
    <id>http://c-maia.github.io/blog/2020/12/23/bitwising-how-do-bitwise-operations-work</id>
    <content type="html"><![CDATA[<!-- wp:paragraph -->


<p>I have a bad memory concerning particular details of programming languages which I don't use very often, and bitwise operations are a good example of such details. Therefore, I decided to develop a Java program that serves the purpose of recapping the concepts that I've learned in school a few years ago.</p>


<!-- /wp:paragraph -->




<!-- wp:paragraph -->


<p>In the following table one may find a short overview of the operations that are covered in the simple program below.</p>


<!-- /wp:paragraph -->




<!-- wp:table -->


<figure class="wp-block-table"><table><tbody><tr><td>Operator</td><td>Name</td><td>Description</td><td>Examples</td></tr><tr><td>~</td><td>not</td><td>Unary operation that performs logical negation on each bit. After negation, bits that have the value 0 will have value 1 and the ones having value 1 will have value 0.</td><td>~4 = -5~&nbsp;00000100
<p>&nbsp;</p>
<p>=11111011</p>
</td></tr><tr><td>&amp;</td><td>and</td><td>Performs the logical AND operation on pairs of corresponding bits of the different numbers. The result is 1 if the pair of bits under comparison is 1, and 0 otherwise.</td><td>7&amp;1 = 100000111 &amp;
<p>&nbsp;</p>
<p>00000001 =</p>
<p>00000001</p>
</td></tr><tr><td>|</td><td>or</td><td>Performs the logical inclusive OR operation on pairs of corresponding bits of the different numbers. The result is 1 if <strong>at least</strong> one of the bits of the pair under comparison is 1, and 0 otherwise.</td><td>7 | 1 = 700000111 |
<p>&nbsp;</p>
<p>00000001 =</p>
<p>00000111</p>
</td></tr><tr><td>^</td><td>xor</td><td>Performs the exclusive OR operation on pairs of corresponding bits of the different numbers. The result is 1 if the pair of bits under comparison is different, and 0 otherwise.</td><td>7^1 = 600000111 ^
<p>&nbsp;</p>
<p>00000001 =</p>
<p>00000110</p>
</td></tr><tr><td>&lt;&lt;</td><td>signed left shift</td><td>Shifts the bit pattern on the left operand n positions to the left. Value n is specified by the right hand side operand. Bits with value of 0 are shifted into the low order positions. Equivalent to multiply by 2, the result of the operation <strong>value &lt;&lt; n</strong> is the same as calculating the expression<strong> value * (2^n)</strong>.</td><td>&nbsp;7 &lt;&lt; 2 =&nbsp;2800000111 &lt;&lt; 2
<p>&nbsp;</p>
<p>=00011100</p>
</td></tr><tr><td>&gt;&gt;</td><td>signed right shift</td><td>Shifts the bit pattern on the left operand n positions to the right. Value n is specified by the right hand side operand. Bits with value of 0 or 1 are shifted into the high order positions in order to preserve the sign. Equivalent to divide by 2. the result of the operation <strong>value &gt;&gt; n</strong> is the same as calculating the expression <strong>value / (2^n)</strong>.</td><td>7 &gt;&gt; 2 = 100000111 &gt;&gt; 2
<p>&nbsp;</p>
<p>=00000001</p>
</td></tr><tr><td>&gt;&gt;&gt;</td><td>unsigned right shift</td><td>This operation is identical to the signed right shift operation with the exception that it inserts 0 in the high order bits, therefore the sign value may change.If the left hand side operand is <strong>positive</strong>, the result will be the same as the signed right shift operation.
<p>&nbsp;</p>
<p>If the left hand side operand is <strong>negative</strong>, the result is equivalent to right shift n positions, specified by the value on the right hand side operand, of the bit pattern on the left-hand side operand. As the high order bits will be zero filled, the sign may change.</p>
</td><td>7 &gt;&gt;&gt; 2 = 100000111 &gt;&gt;&gt; 2
<p>&nbsp;</p>
<p>=00000001</p>
<p>Note: An example with negative numbers is provided in the source code.</p>
</td></tr></tbody></table></figure>


<!-- /wp:table -->




<!-- wp:paragraph -->


<p><strong>Bitwise Operators Demo</strong></p>


<!-- /wp:paragraph -->




<!-- wp:paragraph -->


<p>The program is rather simple. It generates two random numbers between 0 and 5000, and then applies the bitwise operations to the numbers generated.</p>


<!-- /wp:paragraph -->




<!-- wp:paragraph -->


<p>A special method for printing the binary representation of the number was used<br>because AFAIK the method "Integer.toBinaryString(...)" does not return the most<br>significant part of the binary numbers and for my purpose I wanted to have this<br>part represented in the output.</p>


<!-- /wp:paragraph -->




<!-- wp:paragraph -->


<p><strong>Output</strong></p>


<!-- /wp:paragraph -->




<!-- wp:paragraph -->


<p>The generated output is a set of messages containing the results of the performed<br>operations, and looks like this:</p>


<!-- /wp:paragraph -->




<!-- wp:preformatted -->


<pre class="wp-block-preformatted">* Operator: AND &amp;
 Binary representation: 00001000 10101101 - Decimal Representation: 2221
 Binary representation: 00000101 00001000 - Decimal Representation: 1288
 Binary representation: 00000000 00001000 - Decimal Representation: 8</pre>


<!-- /wp:preformatted -->




<!-- wp:paragraph -->


<p><strong><br>Source Code</strong></p>


<!-- /wp:paragraph -->




<!-- wp:preformatted -->


<pre class="wp-block-preformatted">package examples.operators.bitwise;

import java.util.Random;

public class BitwiseOperators
{
public static void main(String[] args)
{
System.out.println("*************************");
System.out.println("* Bitwise Operators Demo");
System.out.println("*************************");

// generate a random Integer between 0 and 5000
Random randomNumber = new Random();
int firstValueGenerated = randomNumber.nextInt(5000);
int secondValueGenerated = randomNumber.nextInt(5000);

System.out.println("First Generated Integer: " + firstValueGenerated);
System.out.println("Second Generated Integer: " + secondValueGenerated);

// print generated numbers in binary
IntToBinary(firstValueGenerated);
IntToBinary(secondValueGenerated);

System.out.println(" ");
System.out.println("*************************");
System.out.println("* Operations &amp; Results   ");
System.out.println("*************************");

System.out.println(" ");
System.out.println("* Operator: NOT (Complement) ~ ");
IntToBinary(firstValueGenerated);
IntToBinary(~firstValueGenerated);

System.out.println(" ");
System.out.println("* Operator: Negative -");
IntToBinary(firstValueGenerated);
IntToBinary(-firstValueGenerated);

System.out.println(" ");
System.out.println("* Operator: AND &amp;");

IntToBinary(firstValueGenerated);
IntToBinary(secondValueGenerated);
IntToBinary(firstValueGenerated &amp; secondValueGenerated);

System.out.println(" ");
System.out.println("* Operator: OR |");

IntToBinary(firstValueGenerated);
IntToBinary(secondValueGenerated);
IntToBinary(firstValueGenerated | secondValueGenerated);

System.out.println(" ");
System.out.println("* Operator: XOR ^");

// 1 if the two bits are different, and 0 if they are the same.
IntToBinary(firstValueGenerated);
IntToBinary(secondValueGenerated);
IntToBinary(firstValueGenerated ^ secondValueGenerated);

System.out.println(" ");
System.out.println("* Operator: Signed left shift &lt;&lt; (i.e. value &lt;&lt; 2)");

IntToBinary(firstValueGenerated);
IntToBinary(firstValueGenerated &lt;&lt; 2); System.out.println(" "); System.out.println("* Operator: Signed right shift >> (i.e. value >> 2)");

IntToBinary(firstValueGenerated);
IntToBinary(firstValueGenerated >> 2);

System.out.println(" ");
System.out.println("* Operator: Unsigned right shift >>> (i.e. value >>> 2)");

IntToBinary(firstValueGenerated);
IntToBinary(firstValueGenerated >>> 2);

System.out.println(" ");
System.out.println("* Operator: Unsigned right shift >> (Negative values: -16 >> 2)");
IntToBinary(-16);
IntToBinary(-16 >> 2);

System.out.println(" ");
System.out.println("* Operator: Unsigned right shift >>> (Negative values: -16 >>> 2)");
IntToBinary(-16);
IntToBinary(-16 >>> 2);

System.out.println(" ");
System.out.println("* Operator: Unsigned right shift >>> (Negative values: -1 >>> 24)");
IntToBinary(-1);
IntToBinary(-1 >>> 24);
}

private static void IntToBinary(int number)
{
String binaryNumber = new String();

// used for formatting the string
int counter = 0;

// check each bit of the number
for (int i = 31; i >= 0; i--)
{
/*
* Here we are interested in the result of the AND operation:
*
* If the AND operation returns a binary number different than 0
* that means that there was a match between the "mask" that we
* are applying and the number, therefore the string value will be 1
*
* If the AND operation returns 0 that means that the "mask" didn't
* match any bit of the number, therefore the number will be 0
*
*/

if( ((1 &lt;&lt;span                data-mce-type="bookmark"                id="mce_SELREST_start"              data-mce-style="overflow:hidden;line-height:0"              style="overflow:hidden;line-height:0"           >&lt;/span>&lt; i) &amp; number) != 0)
{
binaryNumber += "1";
}
else
{
binaryNumber += "0";
}

// separate each 8 bits with a space except the last octet
counter++;
if(counter % 8 == 0 &amp;&amp; i != 0)
{
binaryNumber += " ";
}
}

System.out.println("Binary representation: " + binaryNumber +
" - Decimal Representation: " + number);
}
}</pre>


<!-- /wp:preformatted -->

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Undefined Reference to __udivdi3]]></title>
    <link href="http://c-maia.github.io/blog/2010/08/13/undefined-reference-udivdi3/"/>
    <updated>2010-08-13T23:03:56+00:00</updated>
    <id>http://c-maia.github.io/blog/2010/08/13/undefined-reference-udivdi3</id>
    <content type="html"><![CDATA[<p>During the last month I have been playing with real-time scheduling in the Linux kernel. I’ve downloaded the SCHED_DEADLINE implementation from their git repository and did some changes in some files in order to understand better how real-time task scheduling can be handled in Linux using this particular scheduling policy.</p>

<!-- more -->


<p>I used a 64-bit machine with Ubuntu and Eclipse CDT version to implement my modifications.</p>

<p><strong>You may wonder why do I use Eclipse?</strong><br/>
The answer to that is simple. Eclipse has great code indexing and cross-reference features, which are very helpful in understanding the kernel&rsquo;s inner details.</p>

<p>Moving back to the subject of this post, in my 64-bit machine I’m able to compile a modified version of the kernel without any kind of problems but I’m not able to run the compiled version. After some discussion with an expert in the subject, he told me that probably I wasn’t compiling the correct modules that would allow me to run the OS without any problems. Thus, I decided to re-compile the same modified version in an old 32-bit machine which I wasn’t using anymore, to see if I was able to, at least, run the modified version of the kernel.</p>

<p>The processors I&rsquo;m using are the following:</p>

<p>64-bit machine architecture: &ldquo;model name    : AMD Turion&trade; X2 Dual-Core Mobile RM-74&rdquo;
32-bit machine architecture: &ldquo;model name    : Intel&reg; M processor 1.60GHz&rdquo;</p>

<p>I confess that initially I thought that the compilation process would be smooth, but I got surprised when the code didn’t compile and gcc threw an <strong>Undefined reference to __udivdi3</strong> error.</p>

<p>After some googling, I discovered that the error was thrown in a line where <strong>a division involving u64 data types was being done</strong>. I’ve found some good pointers to the problem, namely:</p>

<p><a href="http://kerneltrap.org/mailarchive/linux-kernel-newbies/2009/2/5/4902104">http://kerneltrap.org/mailarchive/linux-kernel-newbies/2009/2/5/4902104</a><br/>
<a href="https://bugs.launchpad.net/ubuntu/+source/linux-meta/+bug/237528">https://bugs.launchpad.net/ubuntu/+source/linux-meta/+bug/237528</a></p>

<p>So, according to the above posts, it looks like the problem is caused by a compatibility issue between the kernel sources and gcc v4.3. Well, that made sense to consider as I was using that version in the 32-bit machine. However, after an update of the gcc version to v4.4.3, I still got the same error in the 32-bit machine and, surprisingly, with the same version in my 64-bit machine, the kernel compiles smoothly. So, definitely, this was not a compiler&rsquo;s problem but, most probably, an error related to the machine’s architecture and how 64-bit division is performed.</p>

<p>After some googling (again), I’ve found this Stack Overflow thread that somehow fundaments my suspicions: <a href="https://stackoverflow.com/questions/1063585/udivdi3-undefined-how-to-find-the-code-that-uses-it">https://stackoverflow.com/questions/1063585/udivdi3-undefined-how-to-find-the-code-that-uses-it</a></p>

<p>Indeed, it is an architecture&rsquo;s related issue and how division is being handled. After modifying the kernel&rsquo;s code to perform a 64-bit division in a 32-bit architecture, using the <code>uint32_t do_div(uint64_t dividend, uint32_t divisor)</code> function, the code compiled like a charm.</p>

<p>And now let’s run the kernel!</p>
]]></content>
  </entry>
  
</feed>

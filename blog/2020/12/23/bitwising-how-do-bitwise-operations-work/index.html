<!-- wp:paragraph -->


<p>I have a bad memory concerning particular details of programming languages which I don't use very often, and bitwise operations are a good example of such details. Therefore, I decided to develop a Java program that serves the purpose of recapping the concepts that I've learned in school a few years ago.</p>


<!-- /wp:paragraph -->




<!-- wp:paragraph -->


<p>In the following table one may find a short overview of the operations that are covered in the simple program below.</p>


<!-- /wp:paragraph -->




<!-- wp:table -->


<figure class="wp-block-table"><table><tbody><tr><td>Operator</td><td>Name</td><td>Description</td><td>Examples</td></tr><tr><td>~</td><td>not</td><td>Unary operation that performs logical negation on each bit. After negation, bits that have the value 0 will have value 1 and the ones having value 1 will have value 0.</td><td>~4 = -5~&nbsp;00000100
<p>&nbsp;</p>
<p>=11111011</p>
</td></tr><tr><td>&amp;</td><td>and</td><td>Performs the logical AND operation on pairs of corresponding bits of the different numbers. The result is 1 if the pair of bits under comparison is 1, and 0 otherwise.</td><td>7&amp;1 = 100000111 &amp;
<p>&nbsp;</p>
<p>00000001 =</p>
<p>00000001</p>
</td></tr><tr><td>|</td><td>or</td><td>Performs the logical inclusive OR operation on pairs of corresponding bits of the different numbers. The result is 1 if <strong>at least</strong> one of the bits of the pair under comparison is 1, and 0 otherwise.</td><td>7 | 1 = 700000111 |
<p>&nbsp;</p>
<p>00000001 =</p>
<p>00000111</p>
</td></tr><tr><td>^</td><td>xor</td><td>Performs the exclusive OR operation on pairs of corresponding bits of the different numbers. The result is 1 if the pair of bits under comparison is different, and 0 otherwise.</td><td>7^1 = 600000111 ^
<p>&nbsp;</p>
<p>00000001 =</p>
<p>00000110</p>
</td></tr><tr><td>&lt;&lt;</td><td>signed left shift</td><td>Shifts the bit pattern on the left operand n positions to the left. Value n is specified by the right hand side operand. Bits with value of 0 are shifted into the low order positions. Equivalent to multiply by 2, the result of the operation <strong>value &lt;&lt; n</strong> is the same as calculating the expression<strong> value * (2^n)</strong>.</td><td>&nbsp;7 &lt;&lt; 2 =&nbsp;2800000111 &lt;&lt; 2
<p>&nbsp;</p>
<p>=00011100</p>
</td></tr><tr><td>&gt;&gt;</td><td>signed right shift</td><td>Shifts the bit pattern on the left operand n positions to the right. Value n is specified by the right hand side operand. Bits with value of 0 or 1 are shifted into the high order positions in order to preserve the sign. Equivalent to divide by 2. the result of the operation <strong>value &gt;&gt; n</strong> is the same as calculating the expression <strong>value / (2^n)</strong>.</td><td>7 &gt;&gt; 2 = 100000111 &gt;&gt; 2
<p>&nbsp;</p>
<p>=00000001</p>
</td></tr><tr><td>&gt;&gt;&gt;</td><td>unsigned right shift</td><td>This operation is identical to the signed right shift operation with the exception that it inserts 0 in the high order bits, therefore the sign value may change.If the left hand side operand is <strong>positive</strong>, the result will be the same as the signed right shift operation.
<p>&nbsp;</p>
<p>If the left hand side operand is <strong>negative</strong>, the result is equivalent to right shift n positions, specified by the value on the right hand side operand, of the bit pattern on the left-hand side operand. As the high order bits will be zero filled, the sign may change.</p>
</td><td>7 &gt;&gt;&gt; 2 = 100000111 &gt;&gt;&gt; 2
<p>&nbsp;</p>
<p>=00000001</p>
<p>Note: An example with negative numbers is provided in the source code.</p>
</td></tr></tbody></table></figure>


<!-- /wp:table -->




<!-- wp:paragraph -->


<p><strong>Bitwise Operators Demo</strong></p>


<!-- /wp:paragraph -->




<!-- wp:paragraph -->


<p>The program is rather simple. It generates two random numbers between 0 and 5000, and then applies the bitwise operations to the numbers generated.</p>


<!-- /wp:paragraph -->




<!-- wp:paragraph -->


<p>A special method for printing the binary representation of the number was used<br>because AFAIK the method "Integer.toBinaryString(...)" does not return the most<br>significant part of the binary numbers and for my purpose I wanted to have this<br>part represented in the output.</p>


<!-- /wp:paragraph -->




<!-- wp:paragraph -->


<p><strong>Output</strong></p>


<!-- /wp:paragraph -->




<!-- wp:paragraph -->


<p>The generated output is a set of messages containing the results of the performed<br>operations, and looks like this:</p>


<!-- /wp:paragraph -->




<!-- wp:preformatted -->


<pre class="wp-block-preformatted">* Operator: AND &amp;
 Binary representation: 00001000 10101101 - Decimal Representation: 2221
 Binary representation: 00000101 00001000 - Decimal Representation: 1288
 Binary representation: 00000000 00001000 - Decimal Representation: 8</pre>


<!-- /wp:preformatted -->




<!-- wp:paragraph -->


<p><strong><br>Source Code</strong></p>


<!-- /wp:paragraph -->




<!-- wp:preformatted -->


<pre class="wp-block-preformatted">package examples.operators.bitwise;

import java.util.Random;

public class BitwiseOperators
{
public static void main(String[] args)
{
System.out.println("*************************");
System.out.println("* Bitwise Operators Demo");
System.out.println("*************************");

// generate a random Integer between 0 and 5000
Random randomNumber = new Random();
int firstValueGenerated = randomNumber.nextInt(5000);
int secondValueGenerated = randomNumber.nextInt(5000);

System.out.println("First Generated Integer: " + firstValueGenerated);
System.out.println("Second Generated Integer: " + secondValueGenerated);

// print generated numbers in binary
IntToBinary(firstValueGenerated);
IntToBinary(secondValueGenerated);

System.out.println(" ");
System.out.println("*************************");
System.out.println("* Operations &amp; Results   ");
System.out.println("*************************");

System.out.println(" ");
System.out.println("* Operator: NOT (Complement) ~ ");
IntToBinary(firstValueGenerated);
IntToBinary(~firstValueGenerated);

System.out.println(" ");
System.out.println("* Operator: Negative -");
IntToBinary(firstValueGenerated);
IntToBinary(-firstValueGenerated);

System.out.println(" ");
System.out.println("* Operator: AND &amp;");

IntToBinary(firstValueGenerated);
IntToBinary(secondValueGenerated);
IntToBinary(firstValueGenerated &amp; secondValueGenerated);

System.out.println(" ");
System.out.println("* Operator: OR |");

IntToBinary(firstValueGenerated);
IntToBinary(secondValueGenerated);
IntToBinary(firstValueGenerated | secondValueGenerated);

System.out.println(" ");
System.out.println("* Operator: XOR ^");

// 1 if the two bits are different, and 0 if they are the same.
IntToBinary(firstValueGenerated);
IntToBinary(secondValueGenerated);
IntToBinary(firstValueGenerated ^ secondValueGenerated);

System.out.println(" ");
System.out.println("* Operator: Signed left shift &lt;&lt; (i.e. value &lt;&lt; 2)");

IntToBinary(firstValueGenerated);
IntToBinary(firstValueGenerated &lt;&lt; 2); System.out.println(" "); System.out.println("* Operator: Signed right shift >> (i.e. value >> 2)");

IntToBinary(firstValueGenerated);
IntToBinary(firstValueGenerated >> 2);

System.out.println(" ");
System.out.println("* Operator: Unsigned right shift >>> (i.e. value >>> 2)");

IntToBinary(firstValueGenerated);
IntToBinary(firstValueGenerated >>> 2);

System.out.println(" ");
System.out.println("* Operator: Unsigned right shift >> (Negative values: -16 >> 2)");
IntToBinary(-16);
IntToBinary(-16 >> 2);

System.out.println(" ");
System.out.println("* Operator: Unsigned right shift >>> (Negative values: -16 >>> 2)");
IntToBinary(-16);
IntToBinary(-16 >>> 2);

System.out.println(" ");
System.out.println("* Operator: Unsigned right shift >>> (Negative values: -1 >>> 24)");
IntToBinary(-1);
IntToBinary(-1 >>> 24);
}

private static void IntToBinary(int number)
{
String binaryNumber = new String();

// used for formatting the string
int counter = 0;

// check each bit of the number
for (int i = 31; i >= 0; i--)
{
/*
* Here we are interested in the result of the AND operation:
*
* If the AND operation returns a binary number different than 0
* that means that there was a match between the "mask" that we
* are applying and the number, therefore the string value will be 1
*
* If the AND operation returns 0 that means that the "mask" didn't
* match any bit of the number, therefore the number will be 0
*
*/

if( ((1 &lt;&lt;span                data-mce-type="bookmark"                id="mce_SELREST_start"              data-mce-style="overflow:hidden;line-height:0"              style="overflow:hidden;line-height:0"           >&lt;/span>&lt; i) &amp; number) != 0)
{
binaryNumber += "1";
}
else
{
binaryNumber += "0";
}

// separate each 8 bits with a space except the last octet
counter++;
if(counter % 8 == 0 &amp;&amp; i != 0)
{
binaryNumber += " ";
}
}

System.out.println("Binary representation: " + binaryNumber +
" - Decimal Representation: " + number);
}
}</pre>


<!-- /wp:preformatted -->

